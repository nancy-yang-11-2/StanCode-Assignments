Adding lives to the game
class BreakoutGraphics:

    def __init__(self, ball_radius=BALL_RADIUS, paddle_width=PADDLE_WIDTH, paddle_height=PADDLE_HEIGHT,
                 paddle_offset=PADDLE_OFFSET, brick_rows=BRICK_ROWS, brick_cols=BRICK_COLS, brick_width=BRICK_WIDTH,
                 brick_height=BRICK_HEIGHT, brick_offset=BRICK_OFFSET, brick_spacing=BRICK_SPACING, title='Breakout'):
        # Existing initialization code...

        # Initialize lives
        self.lives = NUM_LIVES
        self.lives_label = GLabel(f'Lives: {self.lives}')
        self.lives_label.font = 'Arial-16'
        self.window.add(self.lives_label, 10, 20)  # Position the lives label on the screen

    def update_lives_display(self):
        self.lives_label.text = f'Lives: {self.lives}'

    def decrease_lives(self):
        self.lives -= 1
        self.update_lives_display()
        if self.lives <= 0:
            self.game_over()

    def game_over(self):
        self.window.clear()
        game_over_label = GLabel('Game Over')
        game_over_label.font = 'Arial-36'
        self.window.add(game_over_label, self.window_width // 2 - 100, self.window_height // 2)
        # Pause to show the game over screen
        pause(2000)
        exit()


Modify ball movement and life handling
def move_ball(mouse):
    while True:
        graphics.ball.move(graphics.dx, graphics.dy)
        pause(FRAME_RATE)
        
        # Check for collision with window edges
        if graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:
            graphics.dx = -graphics.dx
        if graphics.ball.y <= 0:
            graphics.dy = -graphics.dy
        if graphics.ball.y + graphics.ball.height >= graphics.window.height:
            graphics.decrease_lives()
            graphics.start_position()
            if graphics.lives <= 0:
                return
        
        # Check for collisions with bricks and paddle
        obj1 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)
        obj2 = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y)
        obj3 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y + graphics.ball.height)
        obj4 = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y + graphics.ball.height)

        for obj in [obj1, obj2, obj3, obj4]:
            if obj is not None:
                if obj is not graphics.paddle:
                    graphics.remove_brick(obj)
                    graphics.dy = -graphics.dy
                else:
                    if graphics.dy > 0:
                        graphics.bounce()


Update breakourgraphics
class BreakoutGraphics:
    def __init__(self, ball_radius=BALL_RADIUS, paddle_width=PADDLE_WIDTH, paddle_height=PADDLE_HEIGHT,
                 paddle_offset=PADDLE_OFFSET, brick_rows=BRICK_ROWS, brick_cols=BRICK_COLS, brick_width=BRICK_WIDTH,
                 brick_height=BRICK_HEIGHT, brick_offset=BRICK_OFFSET, brick_spacing=BRICK_SPACING, title='Breakout'):
        # Existing initialization code...

        # Ball and paddle initialization
        self.reset_ball()
        self.moving = False  # Track whether the ball is moving

    def reset_ball(self):
        self.ball.x = (self.window_width - BALL_RADIUS * 2) // 2
        self.ball.y = (self.window_height - BALL_RADIUS * 2) // 2
        self.dx = random.randint(1, MAX_X_SPEED)
        if random.random() > 0.5:
            self.dx = -self.dx
        self.dy = INITIAL_Y_SPEED

    def update_lives_display(self):
        self.lives_label.text = f'Lives: {self.lives}'

    def decrease_lives(self):
        self.lives -= 1
        self.update_lives_display()
        if self.lives <= 0:
            self.game_over()

    def game_over(self):
        self.window.clear()
        game_over_label = GLabel('Game Over')
        game_over_label.font = 'Arial-36'
        self.window.add(game_over_label, self.window_width // 2 - 100, self.window_height // 2)
        # Pause to show the game over screen
        pause(2000)
        exit()


Update breakout
def move_ball(mouse):
    graphics.moving = True  # Start moving the ball when the mouse is clicked

    while graphics.moving:
        graphics.ball.move(graphics.dx, graphics.dy)
        pause(FRAME_RATE)
        
        # Check for collision with window edges
        if graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:
            graphics.dx = -graphics.dx
        if graphics.ball.y <= 0:
            graphics.dy = -graphics.dy
        if graphics.ball.y + graphics.ball.height >= graphics.window.height:
            graphics.decrease_lives()
            graphics.reset_ball()
            graphics.moving = False  # Stop moving until the next click
        
        # Check for collisions with bricks and paddle
        obj1 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)
        obj2 = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y)
        obj3 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y + graphics.ball.height)
        obj4 = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y + graphics.ball.height)

        for obj in [obj1, obj2, obj3, obj4]:
            if obj is not None:
                if obj is not graphics.paddle:
                    graphics.remove_brick(obj)
                    graphics.dy = -graphics.dy
                else:
                    if graphics.dy > 0:
                        graphics.bounce()


Initialize 

def main():
    onmouseclicked(move_ball)

if __name__ == '__main__':
    main()
